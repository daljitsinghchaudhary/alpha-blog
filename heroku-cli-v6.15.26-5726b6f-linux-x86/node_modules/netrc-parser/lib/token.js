"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
class Base {
    constructor({ pre, post } = {}) {
        this.pre = pre || '';
        this.post = post || '';
    }
    addToken(token) {
        this._tokens = this._tokens || [];
        this._tokens.push(token);
    }
    get content() {
        return [this.pre, this._content, this.post, ...(this._tokens || []).map(e => e.content)].join('');
    }
    get _content() {
        return '';
    }
}
exports.Base = Base;
class Prop extends Base {
    constructor(opts) {
        super(opts);
        this.type = 'prop';
        this.name = opts.name;
        this.value = opts.value;
    }
    get _content() {
        return `${this.name} ${this.value}`;
    }
}
exports.Prop = Prop;
class MachineBase extends Base {
    constructor(_a = {}) {
        var { login, password, account } = _a, opts = tslib_1.__rest(_a, ["login", "password", "account"]);
        super(opts);
        this._tokens = [];
        if (password)
            this.password = password;
        if (account)
            this.account = account;
        if (login)
            this.login = login;
    }
    get login() {
        return this.getProp('login');
    }
    get password() {
        return this.getProp('password');
    }
    get account() {
        return this.getProp('account');
    }
    set login(v) {
        this.setProp('login', v);
    }
    set password(v) {
        this.setProp('password', v);
    }
    set account(v) {
        this.setProp('account', v);
    }
    getProp(name) {
        const p = this._tokens.find(p => p.type === 'prop' && p.name === name);
        return p && p.value;
    }
    setProp(name, value) {
        if (!value) {
            this._tokens = this._tokens.filter(p => p.type === 'prop' && p.name !== name);
            return;
        }
        let p = this._tokens.find(p => p.type === 'prop' && p.name === name);
        if (p) {
            p.value = value;
        }
        else {
            this._tokens.unshift(new Prop({ name, value, pre: this.newPropPre(), post: this.newPropPost() }));
        }
    }
    get _props() {
        return this._tokens.filter(p => p.type === 'prop');
    }
    newPropPre() {
        return this._props[0] ? this._props[0].pre : this.isMultiline() ? '  ' : ' ';
    }
    newPropPost() {
        return this.isMultiline() ? '\n' : '';
    }
    isMultiline() {
        if (!this._tokens.length)
            return true;
        return this._tokens.reduce((c, p) => c + p.content.split('\n').length - 1, this.post.split('\n').length - 1) > 1;
    }
}
exports.MachineBase = MachineBase;
class Machine extends MachineBase {
    constructor(_a) {
        var { host } = _a, opts = tslib_1.__rest(_a, ["host"]);
        super(opts);
        this.type = 'machine';
        this.host = host;
    }
    get _content() {
        return `machine ${this.host}`;
    }
}
exports.Machine = Machine;
class DefaultMachine extends MachineBase {
    constructor() {
        super(...arguments);
        this.type = 'default';
    }
    get _content() {
        return 'default';
    }
}
exports.DefaultMachine = DefaultMachine;
function machinesProxy(tokens = []) {
    return new Proxy({}, {
        get: (_, host) => {
            if (typeof host !== 'string')
                return tokens[host];
            return tokens.find(m => m.type === 'machine' && m.host === host);
        },
        set: (_, host, v) => {
            let idx = tokens.findIndex(m => m.type === 'machine' && m.host === host);
            if (v) {
                let newMachine = new Machine(Object.assign({}, v, { host, post: '\n' }));
                if (idx === -1) {
                    if (tokens.length === 1 && tokens[0].type === 'newline')
                        tokens.splice(0, 1);
                    else
                        tokens.push({ type: 'newline', content: '\n' });
                    tokens.push(newMachine);
                }
                else
                    tokens[idx] = newMachine;
            }
            else if (idx !== -1) {
                tokens.splice(idx, 1);
            }
            return true;
        },
        has: (_, host) => {
            if (typeof host !== 'string')
                return !!tokens[host];
            return !!tokens.find(m => m.type === 'machine' && m.host === host);
        },
        deleteProperty: (_, host) => {
            const idx = tokens.findIndex(m => m.type === 'machine' && m.host === host);
            if (idx === -1)
                return true;
            tokens.splice(idx, 1);
            return true;
        },
    });
}
exports.machinesProxy = machinesProxy;
