'use strict'
Object.defineProperty(exports, '__esModule', { value: true })
const tslib_1 = require('tslib')
const lex_1 = require('./lex')
class Element {
  constructor({ pre = '\n', post = ' ' } = {}) {
    this.pre = pre
    this.post = post
  }
  get content() {
    return `${this.pre}${this._content}${this.post}`
  }
}
exports.Element = Element
class Prop extends Element {
  constructor(opts) {
    super(opts)
    this.name = opts.name
    this.value = opts.value
  }
  get _content() {
    return `${this.name} ${this.value}`
  }
}
exports.Prop = Prop
class MachineBase extends Element {
  constructor(_a) {
    var { props = [] } = _a,
      opts = tslib_1.__rest(_a, ['props'])
    super(opts)
    this.props = props
  }
  get login() {
    return this.getProp('login')
  }
  get password() {
    return this.getProp('password')
  }
  get account() {
    return this.getProp('account')
  }
  set login(v) {
    this.setProp('login', v)
  }
  set password(v) {
    this.setProp('password', v)
  }
  set account(v) {
    this.setProp('account', v)
  }
  get content() {
    return `${this.pre}${this._content}${this.props.map(p => p.content).join('')}${this.post}`
  }
  getProp(name) {
    const p = this.props.find(p => p.name === name)
    return p && p.value
  }
  setProp(name, value) {
    if (!value) {
      this.props = this.props.filter(p => p.name === name)
      return
    }
    let p = this.props.find(p => p.name === name)
    if (p) {
      p.value = value
    } else {
      p = new Prop({ name, value })
      this.props.push(p)
    }
  }
}
exports.MachineBase = MachineBase
class Machine extends MachineBase {
  constructor(_a) {
    var { host } = _a,
      opts = tslib_1.__rest(_a, ['host'])
    super(opts)
    this.type = 'machine'
    this.host = host
  }
  get _content() {
    return `machine ${this.host}`
  }
}
exports.Machine = Machine
class DefaultMachine extends MachineBase {
  constructor() {
    super(...arguments)
    this.type = 'default'
  }
  get _content() {
    return 'default'
  }
}
exports.DefaultMachine = DefaultMachine
function parse(body) {
  const file = {
    machines: {},
    _tokens: [],
  }
  const tokens = lex_1.default(body)
  const getMachineTokens = () => {
    let machineTokens = []
    while (tokens.length && !['machine', 'default', 'macdef'].includes(tokens[0].type)) {
      machineTokens.push(tokens.shift())
    }
    return machineTokens
  }
  while (tokens.length) {
    const cur = tokens.shift()
    switch (cur.type) {
      case 'macdef':
        file._tokens.push(cur, ...getMachineTokens())
        break
      case 'default':
        file.default = machineProxy({ type: 'default', _tokens: getMachineTokens() })
        file._tokens.push(file.default)
        break
      case 'machine':
        let host = cur.host
        file.machines[host]._tokens = getMachineTokens()
        break
      default:
        file._tokens.push(cur)
    }
  }
  return file
}
exports.default = parse
function machinesProxy(content) {
  function addNewMachine(host) {
    let machine = machineProxy({
      type: 'machine',
      host,
      _tokens: [{ type: 'machine', value: host, content: `machine ${host}` }, { type: 'whitespace', content: '\n' }],
    })
    content.push(machine)
    return machine
  }
  return new Proxy(
    {},
    {
      get: (machines, host) => {
        if (typeof host !== 'string') return machines[host]
        if (!machines[host]) machines[host] = addNewMachine(host)
        return machines[host]
      },
      set: (machines, host, value) => {
        if (!machines[host]) machines[host] = addNewMachine(host)
        machines[host] = machineProxy(value)
        return true
      },
      deleteProperty: (machines, host) => {
        if (!machines[host]) return false
        delete machines[host]
        for (let i = 0; i < content.length; i++) {
          if (content[i].type === 'machine' && content[i].value === host) {
            content.splice(i, 1)
          }
        }
        return true
      },
    },
  )
}
function machineProxy(machine) {
  const props = () => machine._tokens.filter(t => t.type === 'prop')
  const loadProps = () =>
    props().forEach(prop => {
      machine[prop.name] = prop.value
    })
  loadProps()
  return new Proxy(machine, {
    set: (machine, name, value) => {
      machine[name] = value
      let prop = props().find(p => p.name === name)
      if (prop) prop.value = value
      else {
        let lastPropIdx = findIndex(machine._tokens, t => t.type === 'prop')
        let whitespace = lastPropIdx === -1 ? { type: 'whitespace', content: '\n  ' } : machine._tokens[lastPropIdx - 1]
        machine._tokens.splice(lastPropIdx, 0, whitespace) // insert whitespace
        machine._tokens.splice(lastPropIdx, 0, { type: 'prop', name, value })
      }
      return true
    },
  })
}
function findIndex(arr, fn) {
  for (let i = 0; i < arr.length; i++) {
    if (fn(arr[i])) return i
  }
  return -1
}
