"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const fs = require("fs");
const os = require("os");
const path = require("path");
const Token = require("./token");
let _debug;
function debug(...args) {
    try {
        if (process.env.NETRC_PARSER_DEBUG !== '1')
            return;
        if (!_debug)
            _debug = require('debug')('netrc-parser');
        _debug(...args);
    }
    catch (err) { }
}
const stdio = [0, null, 2];
/**
 * parses a netrc file
 */
class Netrc extends Token.Base {
    /**
     * generates or parses a netrc file
     * @example
     * const {Netrc} = require('netrc-parser')
     * const netrc = new Netrc()
     * netrc.machines['api.heroku.com'].password // get auth token from ~/.netrc
     */
    constructor(file) {
        super();
        this._file = file;
    }
    get file() {
        return this._file;
    }
    get machines() {
        return this._machines;
    }
    get default() {
        return this._tokens.find(t => t.type === 'default');
    }
    set default(v) {
        let idx = this._tokens.findIndex(t => t.type === 'default');
        if (idx !== -1 && !v)
            this._tokens.splice(idx, 1);
        else {
            let newMachine = new Token.DefaultMachine(Object.assign({}, v, { post: '\n' }));
            if (idx !== -1 && v)
                this._tokens[idx] = newMachine;
            else if (v)
                this._tokens.push(newMachine);
        }
    }
    load() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this._file)
                this._file = yield this.defaultFile();
            this.parse(yield this.readFile());
        });
    }
    loadSync() {
        if (!this._file)
            this._file = this.defaultFile();
        this.parse(this.readFileSync());
    }
    /**
     * save the current home netrc with any changes
     * @example
     * const Netrc = require('netrc-parser')
     * const netrc = new Netrc()
     * await netrc.load()
     * netrc.machines['api.heroku.com'].password = 'newpassword'
     * netrc.save()
     */
    save() {
        return this.write(this.content);
    }
    /**
     * save the current home netrc with any changes
     * @example
     * const Netrc = require('netrc-parser')
     * const netrc = new Netrc()
     * netrc.loadSync()
     * netrc.machines['api.heroku.com'].password = 'newpassword'
     * netrc.saveSync()
     */
    saveSync() {
        this.writeSync(this.content);
    }
    get gpgEncryptArgs() {
        const args = ['-a', '--batch', '--default-recipient-self', '-e'];
        debug('running gpg with args %o', args);
        return args;
    }
    write(body) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (this.file.endsWith('.gpg')) {
                const execa = require('execa');
                const { stdout, code } = yield execa('gpg', this.gpgEncryptArgs, { input: body, stdio: [null, null, 2] });
                if (code)
                    throw new Error(`gpg exited with code ${code}`);
                body = stdout;
            }
            return new Promise((resolve, reject) => {
                fs.writeFile(this.file, body, { mode: 0o600 }, err => (err ? reject(err) : resolve()));
            });
        });
    }
    writeSync(body) {
        if (this.file.endsWith('.gpg')) {
            const execa = require('execa');
            const { stdout, code } = execa.sync('gpg', this.gpgEncryptArgs, { input: body, stdio: [null, null, 2] });
            if (code)
                throw new Error(`gpg exited with code ${status}`);
            body = stdout;
        }
        fs.writeFileSync(this.file, body, { mode: 0o600 });
    }
    parse(body) {
        let lex = require('./lex').default;
        const tokens = lex(body);
        let cur = this;
        for (let token of tokens) {
            switch (token.type) {
                case 'default':
                    cur = new Token.DefaultMachine(token);
                    this.addToken(cur);
                    break;
                case 'machine':
                    cur = new Token.Machine(token);
                    this.addToken(cur);
                    break;
                case 'newline':
                    cur = this;
                    cur.addToken(token);
                    break;
                default:
                    cur.addToken(token);
            }
        }
        this._machines = Token.machinesProxy(this._tokens);
    }
    get gpgDecryptArgs() {
        const args = ['--batch', '--quiet', '--decrypt', this.file];
        debug('running gpg with args %o', args);
        return args;
    }
    readFile() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const decryptFile = () => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const execa = require('execa');
                const { code, stdout } = yield execa('gpg', this.gpgDecryptArgs, { stdio });
                if (code !== 0)
                    throw new Error(`gpg exited with code ${code}`);
                return stdout;
            });
            if (path.extname(this.file) === '.gpg')
                return yield decryptFile();
            else {
                return new Promise((resolve, reject) => {
                    fs.readFile(this.file, { encoding: 'utf8' }, (err, data) => {
                        if (err && err.code !== 'ENOENT')
                            reject(err);
                        resolve(data || '');
                    });
                });
            }
        });
    }
    readFileSync() {
        const decryptFile = () => {
            const execa = require('execa');
            const { stdout, status } = execa.sync('gpg', this.gpgDecryptArgs, { stdio });
            if (status)
                throw new Error(`gpg exited with code ${status}`);
            return stdout;
        };
        if (path.extname(this.file) === '.gpg')
            return decryptFile();
        else {
            try {
                return fs.readFileSync(this.file, 'utf8');
            }
            catch (err) {
                if (err.code !== 'ENOENT')
                    throw err;
                return '';
            }
        }
    }
    get homedir() {
        return ((os.platform() === 'win32' &&
            (process.env.HOME ||
                (process.env.HOMEDRIVE && process.env.HOMEPATH && path.join(process.env.HOMEDRIVE, process.env.HOMEPATH)) ||
                process.env.USERPROFILE)) ||
            os.homedir() ||
            os.tmpdir());
    }
    defaultFile() {
        let file = path.join(this.homedir, os.platform() === 'win32' ? '_netrc' : '.netrc');
        return fs.existsSync(file + '.gpg') ? (file += '.gpg') : file;
    }
}
exports.Netrc = Netrc;
exports.default = new Netrc();
