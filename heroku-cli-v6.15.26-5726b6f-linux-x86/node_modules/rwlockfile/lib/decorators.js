"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
function lockfile(prop, opts = {}) {
    const Lockfile = require('./lockfile').default;
    return methodDecorator(function ({ original, propertyName }) {
        return function (...args) {
            const lockfile = this[prop];
            if (!(lockfile instanceof Lockfile)) {
                throw new Error('prop does not point to a Lockfile instance');
            }
            if (opts.sync) {
                lockfile.addSync({ reason: propertyName.toString() });
                try {
                    return original.apply(this, args);
                }
                finally {
                    lockfile.removeSync();
                }
            }
            else {
                return (() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    yield lockfile.add({ reason: propertyName.toString() });
                    try {
                        return yield original.apply(this, args);
                    }
                    finally {
                        yield lockfile.remove();
                    }
                }))();
            }
        };
    });
}
exports.lockfile = lockfile;
function rwlockfile(prop, type, opts = {}) {
    const RWLockfile = require('./rwlockfile').default;
    return methodDecorator(function ({ original, propertyName }) {
        return function (...args) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const lockfile = this[prop];
                if (!(lockfile instanceof RWLockfile)) {
                    throw new Error('prop does not point to a Lockfile instance');
                }
                const addOpts = {
                    reason: propertyName.toString(),
                };
                if (opts.ifLocked) {
                    addOpts.ifLocked = () => this[opts.ifLocked]();
                }
                yield lockfile.add(type, addOpts);
                let result;
                try {
                    result = yield original.apply(this, args);
                }
                finally {
                    yield lockfile.remove(type);
                }
                return result;
            });
        };
    });
}
exports.rwlockfile = rwlockfile;
function onceAtATime(argKey) {
    return methodDecorator(function ({ original }) {
        const key = Symbol('onceAtATime');
        return function (...args) {
            return tslib_1.__awaiter(this, void 0, void 0, function* () {
                const subKey = argKey !== undefined ? args[argKey] : key;
                const cache = (this[key] = this[key] || {});
                if (cache[subKey])
                    return cache[subKey];
                cache[subKey] = original.apply(this, args);
                try {
                    return yield cache[subKey];
                }
                finally {
                    delete cache[subKey];
                }
            });
        };
    });
}
exports.onceAtATime = onceAtATime;
function methodDecorator(fn) {
    return (target, propertyName, descriptor) => {
        if (isMethodDecorator(descriptor)) {
            descriptor.value = fn({ target, propertyName, descriptor, original: descriptor.value });
            return descriptor;
        }
        else {
            throw new Error(`${propertyName} on ${target} is not a a method`);
        }
    };
}
function isMethodDecorator(prop) {
    if (!prop)
        return false;
    return !!prop.value;
}
